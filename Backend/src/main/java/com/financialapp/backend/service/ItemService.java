package com.financialapp.backend.service;

import com.financialapp.backend.dto.ItemDto;
import com.financialapp.backend.entity.Item;
import com.financialapp.backend.entity.User;
import com.financialapp.backend.repository.ItemRepository;
import com.financialapp.backend.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.math.BigDecimal; // Ensure this is imported for ItemDto
// import java.time.format.DateTimeFormatter; // Not needed if WebClient handles LocalDate -> String JSON

// Imports for Python AI integration
import com.financialapp.backend.dto.PythonFinancialItem;
import com.financialapp.backend.dto.PythonRecommendationRequest;
import com.financialapp.backend.dto.PythonRecommendationResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.http.HttpStatus; // Still import HttpStatus, as WebClient.Builder is in WebFlux.
import reactor.core.publisher.Mono;
import org.springframework.http.HttpStatusCode; // Explicitly import HttpStatusCode for clarity if you need it elsewhere


@Service
public class ItemService {

    @Autowired
    private ItemRepository itemRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired // Inject WebClient.Builder
    private WebClient.Builder webClientBuilder;

    @Value("${python.ai.service.url}") // Inject Python AI service URL from application.properties
    private String pythonAiServiceUrl;

    // Helper method to convert Item entity to ItemDto
    private ItemDto convertToDto(Item item) {
        return new ItemDto(
            item.getId(),
            item.getName(),
            item.getPrice(),
            item.getCategory(),
            item.getDateAdded(),
            item.getDescription()
        );
    }

    // Helper method to convert ItemDto to Item entity
    private Item convertToEntity(ItemDto itemDto, User user) {
        Item item = new Item();
        // ID might be null for new items, will be auto-generated by DB
        item.setId(itemDto.getId()); 
        item.setUser(user); // Set the associated user
        item.setName(itemDto.getName());
        item.setPrice(itemDto.getPrice());
        item.setCategory(itemDto.getCategory());
        // If dateAdded is provided in DTO, use it, otherwise use current date (handled by @PrePersist on entity for new items)
        item.setDateAdded(itemDto.getDateAdded() != null ? itemDto.getDateAdded() : LocalDate.now());
        item.setDescription(itemDto.getDescription());
        return item;
    }


    // --- Item Management Methods ---

    public List<ItemDto> getAllItemsByUserId(Long userId) {
        List<Item> items = itemRepository.findByUserId(userId);
        return items.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    public Optional<ItemDto> getItemById(Long id, Long userId) {
        return itemRepository.findByIdAndUserId(id, userId)
                .map(this::convertToDto);
    }

    @Transactional
    public Optional<ItemDto> addItem(ItemDto itemDto, Long userId) {
        Optional<User> userOptional = userRepository.findById(userId);
        if (userOptional.isEmpty()) {
            return Optional.empty(); // User not found
        }
        User user = userOptional.get();

        Item item = convertToEntity(itemDto, user);
        item.setId(null); // Ensure ID is null for new entity (auto-generated by DB)
        Item savedItem = itemRepository.save(item);
        return Optional.of(convertToDto(savedItem));
    }

    @Transactional
    public Optional<ItemDto> updateItem(Long id, ItemDto itemDto, Long userId) {
        return itemRepository.findByIdAndUserId(id, userId)
                .map(existingItem -> {
                    // Update fields
                    existingItem.setName(itemDto.getName());
                    existingItem.setPrice(itemDto.getPrice());
                    existingItem.setCategory(itemDto.getCategory());
                    // Keep old date if not provided in DTO
                    existingItem.setDateAdded(itemDto.getDateAdded() != null ? itemDto.getDateAdded() : existingItem.getDateAdded());
                    existingItem.setDescription(itemDto.getDescription());
                    Item updatedItem = itemRepository.save(existingItem);
                    return convertToDto(updatedItem);
                });
    }

    @Transactional
    public boolean deleteItem(Long id, Long userId) {
        // First check if the item exists and belongs to the user
        Optional<Item> itemOptional = itemRepository.findByIdAndUserId(id, userId);
        if (itemOptional.isPresent()) {
            itemRepository.delete(itemOptional.get());
            return true;
        }
        return false;
    }

    // --- AI Recommendation Method ---

    public Optional<PythonRecommendationResponse> getAiRecommendation(Long userId) {
        // 1. Fetch all items for the user
        List<Item> userItems = itemRepository.findByUserId(userId);

        if (userItems.isEmpty()) {
            return Optional.empty(); // No items to recommend on
        }

        // 2. Convert SpringBoot Item entities to PythonFinancialItem DTOs
        List<PythonFinancialItem> pythonItems = userItems.stream()
                .map(item -> new PythonFinancialItem(
                        item.getName(),
                        item.getPrice(),
                        item.getCategory(),
                        item.getDateAdded(), // LocalDate will be serialized as "YYYY-MM-DD"
                        item.getDescription()
                ))
                .collect(Collectors.toList());

        // 3. Create the request body for the Python AI service
        PythonRecommendationRequest requestBody = new PythonRecommendationRequest(userId, pythonItems);

        // 4. Make the HTTP call to the Python FastAPI service using WebClient
        WebClient webClient = webClientBuilder.baseUrl(pythonAiServiceUrl).build();

        try {
            PythonRecommendationResponse response = webClient.post()
                    .uri("/generate_recommendation") // Endpoint on Python service
                    .bodyValue(requestBody) // Send our DTO as JSON body
                    .retrieve() // Execute the request
                    // --- CORRECTED LINES BELOW ---
                    .onStatus(status -> status.is4xxClientError(), clientResponse ->
                        clientResponse.bodyToMono(String.class)
                                .flatMap(body -> Mono.error(new RuntimeException(
                                    "Client Error from Python AI Service: " + clientResponse.statusCode() + " - " + body))))
                    .onStatus(status -> status.is5xxServerError(), clientResponse ->
                        clientResponse.bodyToMono(String.class)
                                .flatMap(body -> Mono.error(new RuntimeException(
                                    "Server Error from Python AI Service: " + clientResponse.statusCode() + " - " + body))))
                    // --- END CORRECTED LINES ---
                    .bodyToMono(PythonRecommendationResponse.class) // Expect PythonRecommendationResponse
                    .block(); // Block until response is received (for synchronous flow)

            return Optional.ofNullable(response);

        } catch (RuntimeException e) {
            System.err.println("Error calling Python AI service: " + e.getMessage());
            // Log the error for debugging.
            return Optional.empty();
        }
    }
}